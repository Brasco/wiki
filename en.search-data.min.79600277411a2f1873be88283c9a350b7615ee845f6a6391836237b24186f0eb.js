'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/attacks/timing-attacks/clocks/','title':"Clocks",'section':"Timing Attacks",'content':"We can distinguish two types of clocks - Explicit and Implicit. Explicit clocks are the ones developers use to get direct timing measurements and such mechanisms are offered explicitly by the browser. Implicit clocks on the other hand, misuse particular web features to create unintended clocks which offer a relative timing.\nExplicit Clocks #  performance.now API #  The performance.now() API allows developers to get high-resolution timing measurements.\nperformance.now() API got its accuracy reduced from a range of nanoseconds to a microsecond precision in all modern browsers, to mitigate some XS-Leaks 1 2 3.\n  Reduce resolution of performance.now (Webkit). link \u0026#x21a9;\u0026#xfe0e;\n Reduce precision of performance.now() to 20us (Gecko). link \u0026#x21a9;\u0026#xfe0e;\n Reduce resolution of performance.now to prevent timing attacks (Blink). link \u0026#x21a9;\u0026#xfe0e;\n    Since Firefox 79, this API can be used with full resolution in documents which do not share a browsing context group with cross-origin documents. This will require an application interested in the API to explicitly opt-in to COOP and COEP.  Date API #  The Date API is the oldest API present in browsers to obtain timing measurements. It allows developers to get dates, and get Unix timestamps with Date.now(). These measurements are much less precise compared to performance.now(). Before the introduction of newer APIs attacks used to leverage this instead 1.\nImplicit Clocks #  SharedArrayBuffer and Web Workers #  With the introduction of Web Workers, new mechanisms to exchange data between threads were created 2. SharedArrayBuffer, one of those mechanisms, provides memory sharing between the main thread and a worker thread. Attackers can create an implicit clock with a Worker and use a SharedArrayBuffer as the tunnel to consult this clock. Since the Worker has its own thread, the clock consists of a simple infinite loop iterating over a structure shared with the main thread. This clock does not provide a time measurement, but rather a measurement on how fast the worker thread increments.\n// -------- Main Thread clock creation -------- var buffer = new SharedArrayBuffer(16); var counter = new Worker(\u0026#34;counter.js\u0026#34;); counter.postMessage([buffer],[buffer]); var arr = new UintArray(buffer); relative_time = arr[0]; // -------- Web Worker counter.js -------- self.onmessage = function(event){ var[buffer] = event.data ; var arr = newUintArray(buffer); while(1){ arr[0]++; } } SharedArrayBuffer was removed from browsers with the publication of Spectre. It was reintroduced later in 2020 requiring documents to be in a secure context to make use of the API. This requirement prevents SharedArrayBuffer from being used as an implicit clock.  Other Clocks #  There are a considerable amount of APIs attackers can abuse to create implicit clocks: Broadcast Channel API, Message Channel API, requestAnimationFrame, setTimeout, CSS animations and others 3 4.\nReferences #    Exposing Private Information by Timing Web Applications, link \u0026#x21a9;\u0026#xfe0e;\n Shared memory: Side-channel information leaks, link \u0026#x21a9;\u0026#xfe0e;\n Fantastic Timers and Where to Find Them: High-Resolution Microarchitectural Attacks in JavaScript, link \u0026#x21a9;\u0026#xfe0e;\n Trusted Browsers for Uncertain Times, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':1,'href':'/docs/attacks/xs-search/','title':"XS-Search",'section':"Attacks",'content':"Cross-Site Search (XS-Search) is an important attack and principle in the family of XS-Leaks. The attack abuses Query-Based Search Systems to leak user information from an attacker origin 1 2. The original attack used timing measurements to detect when a search system returned results or no results and works as follows:\n Establish a baseline time for a request returning results (hit) and a baseline for a request with no results (miss). Start a timing attack on the request to the search endpoint, brute-forcing the first character (?q=r). If the measurement is under the hit baseline then add one more character (?q=ra); otherwise try a new one (?q=s). In the end, a full secret (?q=secret) can be leaked.  This attack requires multiple timing measurements to be accurate, something which can be improved with Inflation Techniques and statistical analysis. Furthermore, instead of brute-forcing letter by letter, attackers can search specific words or sentences to leak only the occurrence of results.\nThe most important part of this attack is its principle, as it can be applied in a different number of XS-Leaks.\nInflation Techniques #  The inflation techniques of XS-Search are used to increase the accuracy of the attack to make two responses easier to distinguish (hit or miss). These two mechanisms will allow attackers to make better measurements:\n If a search system reflects certain GET parameters into the response when returning results, it will increase the size of the response. This will make the request more distinguishable because the time to prepare the response and send it over the network will grow substantially. Force the server to perform more computation work before returning a response. This can be possible in search systems offering more expressive query languages (e.g exclude terms in Gmail will need to process every character in the results).  Extended Principle #  While considering the original research around XS-Search an XS-Leak itself, the principle of the attack extends to other XS-Leaks. For example, instead of relying on timing measurements, which are unreliable, attackers can use any other XS-Leak to achieve the same observation.\nIn a Query-Based Search System, a user submits queries and gets responses associated with those queries. From this action, there are two different outcomes:\n The system shows results and the page will present a specific behavior (first state). The system does not show results and the page will present a different behavior from step 1 (second state).  If both behaviors, abstracted in the example above, can be distinguished using any XS-Leak, then an attacker can perform an XS-Search attack with higher levels of impact and reliability. For example, if the number of frames on a page varies based on search results (step 1 and 2 are distinguishable), this attack principle can be applied with a Frame Counting XS-Leak which is much more accurate then one using timing measurements.\nDefense #     Attack Alternative Same-Site Cookies Fetch Metadata COOP Framing Protections     XS-Search (Timing) ✔️ ✔️ ❌ ❌    References #    Cross-Site Search Attacks, link \u0026#x21a9;\u0026#xfe0e;\n Cross-Site Search (XS-Search) Attacks - Hemi Leibowitz, OWASP AppSec IL 2015, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':3,'href':'/docs/attacks/browser-features/corb/','title':"CORB Leaks",'section':"Browser Features",'content':"Cross-Origin Read Blocking (CORB) is a web platform security feature aimed at reducing the impact of speculative side-channel attacks such as Spectre. Unfortunately blocking certain types of requests introduced a new type of XS-Leaks, allowing attackers to detect if CORB was enforced in one request, but wasn\u0026rsquo;t on another. Nevertheless, the introduced XS-Leaks are much less problematic than the issues actively protected by CORB (e.g Spectre).\nCORB \u0026amp; Error Events #  Attackers can observe when CORB is enforced if a response returns a CORB protected Content-Type (and nosniff) with status code 2xx which results in CORB stripping the body and Headers from the response. Detecting this protection will allow an attacker to leak the combination of both the status code (success V.s error) and the Content-Type (protected by CORB or not). This allows the distinction of two possible states:\n One state results in a request being protected by CORB and the second a network error (404). One state is protected by CORB and the second is not.  The following steps could be observed to abuse this protection with the first example:\n An attacker can embed a cross-origin resource in a script tag which returns 200 OK with text/html as Content-Type and a nosniff Header. To protect sensitive contents from entering the attacker\u0026rsquo;s process, CORB will replace the original response with an empty one. Since an empty response is valid JavaScript, the onerror event won\u0026rsquo;t be fired and onload will fire instead. The attacker triggers a second request (corresponding to a second state), similar to 1., which returns something other than 200 OK. The onerror event will fire.  The interesting behavior is that CORB creates a valid resource out of request which could contain something other than JavaScript (causing an error). Considering a non-CORB environment, both 1. and 4. requests would trigger an error. This introduces an XS-Leak as these situations are now distinguishable.\nDetect nosniff Header #  CORB could also allow attackers do detect when the nosniff Header is present in the request. This problem originated due to the fact CORB is only enforced depending on the presence of this header and some sniffing algorithms. The example below shows two distinguishable states:\n CORB will prevent an attacker page which embeds a resource as a script if the resource is served with text/html as Content-Type along with the nosniff Header. If the resource does not set nosniff and CORB fails to infer the Content-Type of the page (which remains text/html), a SyntaxError will be fired since the contents can\u0026rsquo;t be parsed as valid JavaScript. This error can be caught by listening to window.onerror as script tags only trigger error events in certain conditions.  Defense #     Same-Site Cookies Fetch Metadata COOP Framing Protections     ✔️ ✔️ ❌ ❌    This issue is known by Chromium, and while it might remain unfixed, its impact is highly reduced by the rollout of Same-Site Cookies by default in Chromium-based browsers.  Developers can deploy CORP in application resources to force a protection similar to CORB that does not inspect responses to decide when to act. To prevent attackers from abusing this XS-Leak, generic XS-Leaks defense mechanisms are also effective.  References #  "});index.add({'id':4,'href':'/docs/attacks/browser-features/corp/','title':"CORP Leaks",'section':"Browser Features",'content':"Explanation #  Cross-Origin Resource Policy (CORP) is a web platform security feature which enforces CORB. Unfortunately, similarly to CORB XS-Leak applications can introduce a new XS-Leak if they misconfigure the use of this protection.\nA webpage will introduce an XS-Leak if CORP is enforced based on user data. If a page search feature enforces CORP when showing results, but doesn\u0026rsquo;t when returning no results, an attacker will be able to distinguish the two scenarios. This occurs because a page/resource protected by CORP will return a network error when fetched.\nDefense #  An application can avoid this XS-Leak if it guarantees CORP is deployed in all application resources/endpoints. Moreover generic security mechanisms that allow the invalidation of cross-site requests will also help preventing this attack.\n   Same-Site Cookies Fetch Metadata COOP Framing Protections     ✔️ ✔️ ❌ ❌    "});index.add({'id':5,'href':'/docs/attacks/error-events/','title':"Error Events",'section':"Attacks",'content':"When a webpage issues a request to a server (e.g fetch, HTML tags), this request will be received and processed by that server. When received the server will decide whether the request should succeed (e.g 200) or fail (e.g 404) based on the provided context. When a response has an error status an error event will be fired by the browser for the page to handle. These errors are also extended to situations where the parser fails, for example, trying to embed HTML content as an image.\nFor example, attackers can detect whether a user is logged into a service by checking if the user has access to resources only available to authenticated users 1. The impact of this XS-Leak varies depending on the application but it can lead to sophisticated attacks with the ability to deanonymize users 2.\nError events can be thrown from a large variety of HTML tags, and some behaviors vary from browser to browser 3   \\(^{p. 6}\\)  . For instance, they depend on the loaded resources, HTML tags, presence of certain Headers (e.g nosniff, Content-Type) or enforcement of default browser protections, etc.\nThe principle of leaking information with error events can be abstracted and applied to a variety of XS-Leaks. For example one of Cache Probing alternatives use Error Events to detect if a certain image was cached by the browser.\nDefense #  The mitigation of this XS-Leak often varies on how applications handle certain resources and ends in the adoption of consistent behaviors as much as possible. In specific scenarios, applications might use Subresource Protections to prevent attackers from predicting an URL and go forward with an attack.\nFinally, without applying bigger changes in the logic of applications, generic web platform security features could be deployed to mitigate this XS-Leak at a larger scale.\n   Same-Site Cookies Fetch Metadata COOP Framing Protections     ✔️ \\(^{🔗}\\)   ✔️ ❌ ✔️ \\(^{🔗}\\)      🔗 - Defense mechanisms must be combined to be effective against different scenarios.\nReal World Example #   A bug abused a Twitter API endpoint where only a specified user would have access to it. This endpoint would cause an error to every Twitter user but the owner. An attacker could exploit this difference to deanonymize a user with one of its pages 1. Similarly, another bug abused an image authentication mechanism of private messages to achieve the same goal 4 2.  References #    Twitter ID exposure via error-based side-channel attack, link \u0026#x21a9;\u0026#xfe0e;\n Leaky Images: Targeted Privacy Attacks in the Web, link \u0026#x21a9;\u0026#xfe0e;\n Cross-Origin State Inference (COSI) Attacks: Leaking Web Site States through XS-Leaks, link \u0026#x21a9;\u0026#xfe0e;\n Tracking of users on third-party websites using the Twitter cookie, due to a flaw in authenticating image requests, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':6,'href':'/docs/attacks/frame-counting/','title':"Frame Counting",'section':"Attacks",'content':"Window references allow cross-origin pages to get access to some attributes of other pages. These references become available when using or allowing iframe and window.open. They provide some information (although limited) about the window as they still respect the Same Origin Policy.\nOne of the accessible attributes is window.length which provides the number of frames in the window. This attribute can give valuable information about a page to an attacker.\nWebsites commonly use frames (or iframes) and this choice doesn\u0026rsquo;t necessarily imply security issues. There are however cases where a website might change the number of frames in a page depending on some user information. This could happen for example on a page that changes layout depending on the GET parameters and the victim data. It might be possible for an attacker to infer information on the victim by navigating a frame or a window with different GET requests and checking the value of window.length afterwards.\nAttack alternatives #  In some cases, different application states have the same number of frames, preventing attackers to be able to distinguish them. However, continuously recording the frame count when the page is loading can lead to a pattern attackers might be able to use.\nconst win = window.open(\u0026#34;https://target.page\u0026#34;); // Or any Window reference const pattern = []; const recorder = setInterval(() =\u0026gt; pattern.push(win.frames.length), 0); setTimeout(() =\u0026gt; { clearInterval(recorder); console.log(pattern); }, 6 * 1000); Case Scenarios #   A website lets a user search for user information in a search engine, if the page structure has a different number of iframes depending on whether there are results to the user query, an attacker could use the XS-Search technique to leak those secrets. A website structures the user profile page differently based on gender or other PII. An attacker can easily leak this information by just opening the page and counting frames.  Defense #     Attack Alternative Same-Site Cookies Fetch Metadata COOP Framing Protections     iframe ✔️ ✔️ ❌ ✔️   window.open ✔️ (if Strict) ✔️ ✔️ ❌    Real World Example #  A Vulnerability reported to Facebook used this technique to leak user-related information such as specific contents published in posts, religious information about friends, or photo locations1.\nReferences #    Patched Facebook Vulnerability Could Have Exposed Private Information About You and Your Friends. link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':7,'href':'/docs/attacks/navigations/','title':"Navigations",'section':"Attacks",'content':"Detecting if a cross-site page triggered a navigation (or didn\u0026rsquo;t) can be useful to an attacker. For example, a website may trigger a navigation in a certain endpoint depending on the status of the user.\nTo detect if any kind of navigation occurred, an attacker can:\n Use an iframe and count the number of times the onload event is triggered. Check the value of History.length, accessible through any window reference. This gives the number of entries in the history of a victim either changed by History.pushState or regular navigations. To get the value of History.length an attacker changes the location of the window reference with the target website, changes back to same-origin, and finally reads the value.  Download Trigger #  When endpoints set the Content-Disposition: attachment Header, it instructs the browser to download the response as an attachment instead of navigating to it. Detecting if this behavior occurred might allow attackers to leak private information, considering this outcome might depend on the state of the victim\u0026rsquo;s account and navigations.\nDownload bar #  In Chromium-based browsers when a file is downloaded, a preview of the download process appears in a bar at the bottom, integrated into the browser window. By monitoring the window height attackers could detect whether the \u0026ldquo;download bar\u0026rdquo; opened.\n// Any Window reference (can also be done using an iframe in some cases) const tab = window.opener; // The current window height const screenHeight = window.innerHeight; // The size of the chrome download bar on, for example, mac os x const downloadsBarSize = 49; tab.location = \u0026#39;https://target.page\u0026#39;; setTimeout(() =\u0026gt; { let margin = screenHeight - window.innerHeight; if (margin === downloadsBarSize) { return console.log(\u0026#39;downloads bar detected\u0026#39;); } }, 5 * 1000); This attack is only possible in Chromium-based browsers.  Download Navigation #  Another way to test for the Content-Disposition: attachment Header is to check if a navigation occurred. If a page load causes a download, it will not trigger a navigation.\n Open an attacker origin with window.open and save the window reference. Navigate the saved reference to the endpoint that might download. After a timeout, check if the window is still same-origin  The snippet presented in the Cross-Window Timing XS-Leak can be slightly adapted to detect this behavior.\nDownload Navigation (without timeout) #  The following snippet can obtain a more precise measurement without relying on timeouts and imprecise timings.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  onmessage = e =\u0026gt; console.log(e.data); var outer = document.createElement(\u0026#39;iframe\u0026#39;); var url = \u0026#39;https://target.page\u0026#39;; outer.src = `data:text/html,\\\u0026lt;iframe id=\u0026#39;inner\u0026#39; src=\u0026#34;${url}\u0026#34; \u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;!-- onload is part of outer iframe --\u0026gt; \u0026lt;script\u0026gt;onload=()=\u0026gt;{ try { inner.contentWindow.location.href; top.postMessage(\u0026#39;download attempt\u0026#39;,\u0026#39;*\u0026#39;); } catch(e) { top.postMessage(\u0026#39;no download\u0026#39;,\u0026#39;*\u0026#39;); } }%3c/script\u0026gt;`; outer.onload = ()=\u0026gt;{outer.remove();} document.body.appendChild(outer);    The attack works as follows:\n Include an iframe (inner) inside an iframe (outer). The inner iframe embeds the target website. If the target website triggers a download the inner iframe origin will remain about:blank (downloads don’t navigate). Even though the download attempt doesn\u0026rsquo;t trigger an onload event on the inner iframe, the window of the outer iframe (line 7) still waits for the resource to start the download and fires the onload event. If a navigation has occurred the inner iframe will change its origin. When the outer iframe onload fires the outer iframe verifies if i.contentWindow.location.href (line 9) is accessible, only possible if both iframes share the same origin (Same-Origin Policy is enforced). If both iframes are in different origins, a DOMException will be thrown, meaning a navigation occurred.  Server-Side Redirects #  Inflation #  A server-side redirect can be detected from a cross-origin page when the destination URL increases in size and reflects a user input, either in the form of a query string parameter or a path. The following technique relies on the fact that it is possible to induce an error in most web-servers by generating big requests parameters/paths. Since the redirect increases the size of the URL, it can be detected by sending exactly one character less than the server maximum capacity. That way if the size increases the server will respond with an error code that can be detected from a cross-origin page using common DOM APIs.\nCross-Origin Redirects #  CSP Violations #  Content-Security-Policy (CSP) is an in-depth defense mechanism against XSS and data injection attacks. When a CSP is violated, a SecurityPolicyViolationEvent is thrown. An attacker can set up a CSP which will trigger a Violation event every time a fetch follows an URL not set in the CSP directive. This will allow an attacker to detect if a redirect to another origin occurred 1 2.\nThe example below will trigger a SecurityPolicyViolationEvent if the website set in fetch API (line 6) redirects to a website different then target.page.\n1 2 3 4 5 6 7  \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;unsafe-inline\u0026#39; target.page\u0026#34;\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;securitypolicyviolation\u0026#39;, e =\u0026gt; { console.log(\u0026#34;redirected\u0026#34;); }); fetch(\u0026#39;https://target.page/might_redirect\u0026#39;, {mode: \u0026#39;no-cors\u0026#39;,credentials: \u0026#39;include\u0026#39;}); \u0026lt;/script\u0026gt;   Case Scenarios #   An online bank decides to redirect wealthy users to unmissable stock opportunities by triggering a navigation to a reserved space on the website when users are consulting the account balance. If this is only done to a specific group of users, it becomes possible for an attacker to leak the \u0026ldquo;client status\u0026rdquo; of the user.  Defense #     Attack Alternative Same-Site Cookies Fetch Metadata COOP Framing Protections     iframe ✔️ ✔️ ❌ ✔️   History.length (iframe) ✔️ ✔️ ❌ ✔️   History.length (window.open) ✔️ (if Strict) ✔️ ✔️ ❌   Download bar ✔️ ✔️ ✔️ ✔️   Download Navigation (w/ timeout) ✔️ (if Strict) ✔️ ❓ ✔️   Download Navigation (no timeout) ✔️ ✔️ ✔️ ✔️   CSP Violations ✔️ ✔️ ❌ ❌    Real-World Examples #   A vulnerability reported to Twitter used this technique to leak the contents of private tweets using XS-Search. This attack was possible because the page would only trigger a navigation depending on whether there were results to the user query 3.  References #    Disclose domain of redirect destination taking advantage of CSP, link \u0026#x21a9;\u0026#xfe0e;\n Using Content-Security-Policy for Evil, link \u0026#x21a9;\u0026#xfe0e;\n Protected tweets exposure through the url, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':8,'href':'/docs/attacks/timing-attacks/network-timing/','title':"Network Timing",'section':"Timing Attacks",'content':"Network Timing side-channels have been present on the web since its beginning 1 2. These attacks achieved different levels of impact over time, gaining new attention when browsers started shipping high precision timers like performance.now().\nTo obtain timing measurements attackers must use a clock, either an implicit or explicit one. These clocks are usually interchangeable and only vary in accuracy and availability. For simplicity, this article will only address the performance.now() API, an explicit clock present in all modern browsers.\nThis side-channel allows attackers to infer information from a cross-site request based on how much time it takes to complete that request 3. The network timing measurement may vary based on a user state and it\u0026rsquo;s usually connected to:\n Resource Size. The computation time in the backend. Amount of sub-resources. Cache status.  Learn more about the different types of clocks in the Clocks Article.  Modern Web Timing Attacks #  The performance.now() API can be used to measure how much time it takes to perform a request.\nlet before = performance.now() await fetch(\u0026#39;https://target-website.com\u0026#39;,{\u0026#39;mode\u0026#39;:\u0026#39;no-cors\u0026#39;,\u0026#39;credentials\u0026#39;:\u0026#39;include\u0026#39;}) let request_time = performance.now() - before Frame Timing Attacks (Network) #  If the target page enforces Framing Protections, embedding it as an iframe allows an attacker to obtain a network timing measurement. The example below shows how to achieve this by starting a clock, embedding the page as an iframe (request is started), and wait for the onload event to be triggered which means the request completed. In this scenario when the request completes the browser does not render the fetched resource because of the protection.\nbegin = performance.now(); var x = document.createElement(\u0026#39;iframe\u0026#39;); x.src = \u0026#34;https://target.page\u0026#34;; document.body.appendChild(x); start = performance.now(); x.onload = () =\u0026gt; console.log(performance.now() - begin) Sandboxed Frame Timing Attacks #  When a page sets Framing Protections, an attacker can obtain an almost pure network measurement by including the sandbox attribute in the iframe. This attribute will block all JavaScript execution and prevent some subresources from loading.\nCross-window Timing Attacks #  An attacker can also measure the network timing of a page by opening a new window with window.open and wait for the window to start loading. The snippet below shows how to make this measurement and works as follows:\n The attacker creates an infinite loop of postMessage broadcasts to itself while opening a window to the target website (lines 15, 2, 7). The clock is started (line 14). When the window is created, its location will be about:blank until the target page starts loading. In the infinite loop, the logic clause (line 4) will be true while the opened window remains in about:blank as its document it\u0026rsquo;s still accessible from the attacker\u0026rsquo;s origin. When the window starts loading, the location will change from about:blank to the target\u0026rsquo;s origin. The attacker\u0026rsquo;s origin won\u0026rsquo;t have access to the document of the opened window as per Same-Origin Policy. When this occurs, the logic clause (line 4) will fail and throw a DOMException. The attacker catches the Exception and stops the clock.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let w = 0, end = 0, begin = 0; onmessage=()=\u0026gt;{ try{ if(w \u0026amp;\u0026amp; w.document.cookie){ // still same origin  } postMessage(\u0026#39;\u0026#39;,\u0026#39;*\u0026#39;); }catch(e){ end = performance.now(); console.log(\u0026#39;time to load was\u0026#39;, end - begin); } }; postMessage(\u0026#39;\u0026#39;,\u0026#39;*\u0026#39;); begin = performance.now(); w = open(\u0026#39;//mail.com/search?q=foo\u0026#39;);    This technique can also be adapted to measure the Execution Timing of a page by making the event loop busy.  Timeless Timing Attacks #  Other attacks do not consider the notion of time to perform a timing attack 4. Timeless attacks consist of fitting two HTTP requests in a single packet, the baseline and the attacked request, to guarantee they arrive at the same time to the server. The server will process the requests concurrently, and return a response based on their execution time as soon as possible. One of the two requests will arrive first, allowing the attacker to get the timing difference by comparing both requests.\nThe advantage of this technique is the independence on network jitter and uncertain delays, something that is always present in the remaining techniques.\nThe original research needs to be adapted to work in a browser since it handles all network-specific tasks.  This attack is limited to specific versions of HTTP and joint scenarios. It makes certain assumptions and has requirements regarding server behaviors.  Defense #     Attack Alternative Same-Site Cookies Fetch Metadata COOP Framing Protections     Modern Timing Attacks ✔️ ✔️ ❌ ❌   Frame Timing (Network) ✔️ ✔️ ❌ -   Frame Timing (Sandbox) ✔️ ✔️ ❌ -   Cross-window Timing ✔️ (if Strict) ✔️ ❌ ❌   Timeless Timing ✔️ ❓ ❌ ❌    References #    Exposing Private Information by Timing Web Applications, link \u0026#x21a9;\u0026#xfe0e;\n Cross-domain search timing, link \u0026#x21a9;\u0026#xfe0e;\n The Clock is Still Ticking: Timing Attacks in the Modern Web - Section 4.3.3, link \u0026#x21a9;\u0026#xfe0e;\n Timeless Timing Attacks: Exploiting Concurrency to Leak Secrets over Remote Connections, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':9,'href':'/docs/attacks/cache-probing/','title':"Cache Probing",'section':"Attacks",'content':"The principle of Cache Probing consists of detecting whether some resource was cached by the browser. The concept is known since the begging of the web 1 and initially used timing differences to succeed.\nWhen a user visits a website some resources such as images, scripts, and HTML content are fetched and later cached by the browser (under certain conditions). This optimization will make future navigations faster as the browser will serve those resources from disk instead of requesting them again. If an attacker can detect which resources are cached it may be enough to leak whether a user accessed a specific page in the past.\nA variation of the original concept abused Error Events to perform more accurate and impactful attacks, including tricks to invalidate resources from the cache (to make better inferences).\nAttack Principle #  An attacker wants to know whether a user visited a certain social network.\n A user visits a social network and some of the subresources will be cached. This step might not happen depending on user behavior. The user visits an attacker-controlled page which will fetch a resource that is usually fetched by that social network. Using a Network Timing XS-Leak, the attacker page can detect the difference from a response coming from the cache (step 1 happened) or coming from the network (step 1 did not happen). The delay will be significantly lower in a request served from the cache.  Cache Probing with Error Events #  Cache Probing with Error Events 2 allows more accurate and impactful attacks. Instead of relying on timing measurements, they leverage Error Events and some server behaviors to detect whether a resource was cached. It also uses a trick to invalidate resources from the cache. The attack works as follows:\n Invalidate the resource from the browser cache. This step is required to make sure the attack will not consider a resource previously cached in another visit. Perform a request to load subresources of the target website. This can be done by navigating to the target website with \u0026lt;link rel=prerender.., embedding the website in an iframe or opening a new window with window.open. Perform a request with an overlong referrer which will usually make the server fail when receiving the request. If the resource was cached in step 2, this request will succeed instead.  Invalidate the cache #  To invalidate a resource from the cache the attacker must force the server to return an error when fetching that subresource. There are a couple of ways to achieve this:\n A request with an overlong referrer and 'cache':'reload'. This might not work as browsers capped the length of the referrer to prevent this. A POST request with a fetch no-cors. Sometimes even in cases where an error is not returned the browser invalidates the cache. Request Headers such as Content-Type, Accept, Accept-Language, etc that may cause the server to fail (more application dependent). Other request properties.  Often some of these alternatives might be considered a browser bug.\nDefense #  Opt-in Defense Mechanisms #     Same-Site Cookies Vary: Sec-Fetch-Site Subresource Protections     ✔️ (if Strict) ✔️ ✔️ \u0026amp; ❌ *     If a resource can be fetched with user authentication, Same-Site Cookies (Strict) should be considered to protect that resource from being abused by an attacker origin. Vary: Sec-Fetch-Site allows applications to force cache segregation by a group of origins. Subresource Protections allow application to set random tokens in URLs to make them unpredictable from attackers. Useful for both authenticated and unauthenticated subresources.  Default Defense Mechanisms #  Paritioned Caches, a feature implemented in browsers to create a unique cache for each origin. This protection prevents an attacker\u0026rsquo;s origin to interfere with cached resources of other origins. Applications do not have to opt-in to enforce this.\nPartitioned Caches are not available in most browsers by default, so applications cannot rely on them as of September 2020.  Real World Example #   An attacker using the Error Events Cache Probing could detect whether a user watched a specific YouTube Video by checking if the video thumbnail ended up in browser cache 3.  References #    Timing Attacks on Web Privacy, link \u0026#x21a9;\u0026#xfe0e;\n HTTP Cache Cross-Site Leaks, link \u0026#x21a9;\u0026#xfe0e;\n Mass XS-Search using Cache Attack, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':10,'href':'/docs/attacks/timing-attacks/execution-timing/','title':"Execution Timing",'section':"Timing Attacks",'content':"Measuring the time of JavaScript execution in a browser can give attackers information on when certain events are triggered, and how long some operations take.\nTiming the Event Loop #  JavaScript concurrency model is based on a single-threaded event loop which means it can only run one task at a time. If, for example, some time-consuming task blocks the event loop, the user can perceive a freeze on a page as a result of the UI thread being starved. Other tasks must wait until the blocking one runs to conclusion. Each browser implements different process models, which means some web sites might run in different threads (and event loops) depending on their relations.\nSome attacks exploit this model to steal secrets from a cross-origin page:\n Infer how long code from a different origin takes to run by measuring how long it takes to run next in the event pool 1 2. The attacker keeps sending events to the event loop with fixed properties, which will eventually be dispatched if the pool is empty. Other origins will dispatch events to the same pool, and this is where an attacker infers the timing difference by detecting if a delay occurred with one of its tasks. Steal a secret from a cross-origin page if the said secret is being compared by an attacker-controlled string. The leak is a result of comparing timing differences in the event loop of a char-by-char string comparison 2 (using the previous technique). In browsers without process isolation, cross-window communications between different origins will run in the same thread, thus sharing the same event loop.  This attack is no longer possible in Browsers with process isolation mechanisms in place. Such mechanisms are only present in Chromium-Based browsers with Site Isolation and soon in Firefox under Project Fission.  Busy Event Loop #  Another technique to measure JavaScript Execution consists of blocking the event loop of a thread and time how long does it take for the event loop to be available again. One of the main advantages of this attack is its ability to circumvent Site Isolation as an attacker origin can mess with the execution of another origin. The attack works as follows:\n Navigate the target website in a separate window with window.open or inside an iframe (if Framing Protections are not in place). Wait for the long computation to start. Load any same-site page inside an iframe, regardless of any Framing Protections.  An attacker can detect how long the target website is executed by timing how long it took for the iframe (in step 3) to trigger the onload event (Network Timing of step 3 should be despicable). Since both navigations occurred within the same context and they are same-site, they run in the same thread and share the same event loop (they can block each other).\nThe example below shows how the measurement can be obtained, using the same technique described in Cross-Window (Network) Timing Attacks for step 2 to detect when the window stated loading.\nlet w = 0, end = 0, begin = 0; onmessage=()=\u0026gt;{ try{ if(w \u0026amp;\u0026amp; w.document.cookie){ // still same origin  } postMessage(\u0026#39;\u0026#39;,\u0026#39;*\u0026#39;); }catch(e){ begin = performance.now(); var x = document.createElement(\u0026#39;iframe\u0026#39;); x.src = \u0026#34;https://any-same-site.target.page\u0026#34;; document.body.appendChild(x); start = performance.now(); x.onload = () =\u0026gt; console.log(performance.now() - begin) } }; postMessage(\u0026#39;\u0026#39;,\u0026#39;*\u0026#39;); w = open(\u0026#39;https://target.page\u0026#39;); Service Workers #  Service Workers can be used to offer offline solutions to web applications but it might be abused by attackers to measure the timing of javascript execution3. They serve as a proxy between the browser and the network and allow applications to intercept any network requests made by the main thread (document).\nTo make a timing measurement an attacker can perform the following steps:\n The attacker registers a service worker in one of its domains (attacker.com). In the main document, the attacker issues a navigation (window.open) to the target website and instructs the Service Worker to start a timer. When the new window starts loading the attacker will navigate the reference obtained in step 2 to a page handled by the service worker. When the request performed in step 3 arrives to the Service Worker it will return a 204 (No Content) response, which will abort the navigation. At this point the Service Worker will collect a measurement from the timer started in step 2. This measurement will be affected by how long JavaScript blocked the navigation for.  Since the navigation won\u0026rsquo;t actually happen, steps from 3 to 5 can be repeated to get more measurements on successive JavaScript execution timings.\nCSS Injections #  This group of XS-Leaks requires a CSS Injection on the target page.  Among the different CSS Injection vectors, the most noticeable one is the abuse of CSS Selectors. They can be used as an expression to match and select certain HTML elements. For example, the selector input[value^=\u0026quot;a\u0026quot;] will be matched if the value of an input tag starts with the character \u0026ldquo;a\u0026rdquo;. So, to detect if a CSS Selector matched the expression, attackers could trigger a callback to one of their websites using certain properties like background, @import, etc 4 5. The matching process can be easily brute-forced, and extended to the full string.\njQuery, CSS Selectors \u0026amp; Short-circuit Timing #  Attackers can abuse another interesting behavior of CSS selectors which is short-circuit evaluation of expressions. This expression is received in an URL hash and evaluated if the page executes jQuery(location.hash) 6.\nA timing attack is possible because the expression is compared from right to left, so if the selector main[id='site-main'] does not match and fails to evaluate, the other parts of the selector (*:has(*:has(*:has(*))))) which take longer to execute, are ignored (just like the and operator but backwards).\n$(\u0026#34;*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id=\u0026#39;site-main\u0026#39;]\u0026#34;) This attack is no longer possible in Browsers with process isolation mechanisms in place. Such mechanisms are only present in Chromium-Based browsers with Site Isolation and soon in Firefox under Project Fission.  In browsers with process isolation mechanisms, Service Workers can be abused to obtain the execution timing measurement or tricks like Busy Event Loop tricks to circumvent Site Isolation.  ReDoS #  This group of XS-Leaks requires an injection of Regex Expressions on the target page.  Regular Expression Denial of Service (ReDoS) it\u0026rsquo;s an attack which result in a Denial of Service in applications that allow Regex as user input 2 7. The DoS results from an injected Regex that would run in exponential time. Some attacks applied this principle into leaking information: The attacker\u0026rsquo;s injection cause a DoS if the Regex matches a character in some secret and computes quickly otherwise. This could happen in both client and server side.\nDefense #     Attack Alternative Same-Site Cookies Fetch Metadata COOP Framing Protections     T. Event Loop ✔️ (if Strict) ✔️ ❓ ❌   Service Workers ✔️ ✔️ ✔️ ❌   jQuery ✔️ ✔️ ❌ ❌   ReDoS ✔️ ✔️ ❌ ❌   Busy Event Loop ✔️ ✔️ ❌ ❌    References #    Loophole: Timing Attacks on Shared Event Loops in Chrome, link \u0026#x21a9;\u0026#xfe0e;\n Matryoshka - Web Application Timing Attacks (or.. Timing Attacks against JavaScript Applications in Browsers), link \u0026#x21a9;\u0026#xfe0e;\n Security: XS-Search + XSS Auditor = Not Cool, link \u0026#x21a9;\u0026#xfe0e;\n CSS Injection Primitives, link \u0026#x21a9;\u0026#xfe0e;\n HTTPLeaks, link \u0026#x21a9;\u0026#xfe0e;\n A timing attack with CSS selectors and Javascript, link \u0026#x21a9;\u0026#xfe0e;\n A Rough Idea of Blind Regular Expression Injection Attack, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':11,'href':'/docs/attacks/timing-attacks/hybrid-timing/','title':"Hybrid Timing",'section':"Timing Attacks",'content':"Hybrid Timing Attacks allow attackers to measure a combination of factors that influence the final timing measurement. These factors can be:\n Network. Parsing. Retrieve and load subresources. Execution.  Some of the factors differ in value depending on the application. This means that Network Timing might be more observable in pages with more backend processing while Execution Timing can be more observable in applications processing and displaying data within the browser. Attackers can also eliminate some of the factors of the equation to obtain better measurements, for example, one could preload all the subresources by embedding the page as an iframe (forcing the browser to cache them) and do a second measurement which will exclude any delay introduced by the retrieval of those subresources.\nFrame Timing Attacks (Hybrid) #  If a page does not set Framing Protections, an attacker can obtain a hybrid measurement that considers all the factors. This attack is similar to the Network-based Attack, but when the resource is retrieved the page is rendered and executed by the browser (subresources fetched and JavaScript executed). In this scenario, the onload event only triggers when the page fully loads.\n\u0026lt;iframe name=f id=g\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;script\u0026gt; before = performance.now(); f.location = \u0026#39;https://target.page\u0026#39;; g.onerror = g.onload = ()=\u0026gt;{ console.log(\u0026#39;time was\u0026#39;, performance.now() - before) }; \u0026lt;/script\u0026gt; Defense #     Attack Alternative Same-Site Cookies Fetch Metadata COOP Framing Protections     Frame Timing (Hybrid) ✔️ ✔️ ❌ ✔️    "});index.add({'id':12,'href':'/docs/attacks/id-attribute/','title':"ID Attribute",'section':"Attacks",'content':"The id attribute is widely used to identify some HTML elements. Unfortunately, these ids can be leaked by leveraging the focus event and the URL fragment. For example, some web applications set id attributes in focusable elements that may lead to user information disclosure. These ids can either be direct information related to the user (e.g a secret) or information associated with a user state (e.g account status). There are two alternatives to complete this attack:\n By using an iframe an attacker can load the target website once and brute-force the URL hash until the focus event fires. The onblur event can be used to detect when the target has focus 1.  Case Scenarios #   A bank allows its clients to generate 4 digit One-Time PINs (OTP) in the browser application to authenticate sessions on the mobile. The bank did a couple of mistakes and put the 4 digit OTP as the id of a button, used to show the PIN to the client. By targeting clients using the properties of this XS-Leak, it might be possible to compromise their accounts. A web application uses a specific set of predefined ids and HTML elements when an account has a premium status or the user is of a certain gender. The attacker can detect whether a specific id is present on the victim\u0026rsquo;s page and leak the account information.  Defense #     Attack Alternative Same-Site Cookies Fetch Metadata COOP Framing Protections     iframe ✔️ ✔️ ❌ ✔️    References #    Leaking IDs using focus, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':13,'href':'/docs/attacks/postmessage-broadcasts/','title':"postMessage Broadcasts",'section':"Attacks",'content':"Applications often use postMessage broadcasts to provide information to any interested origin. Apart from the obvious security issues (providing sensitive information to any origin), other problems might occur if a legitimate postMessage broadcast is not properly implemented 1.\nIf a broadcast happens based on user information, attackers might be able to leak information if they can distinguish two scenarios. There are multiple ways applications can be inconsistent with broadcast:\n An application sends different broadcasted messages. An application sends a broadcast or no broadcast.  Defense #  There is no clear solution to mitigate this XS-Leak as it depends deeply on the purpose of doing a postMessage broadcast. Applications should limit postMessage communications to a group of known origins and, when this is not possible, they should have the same behavior even when in different states to prevent attackers from inferring any differences.\nReferences #    Cross-Origin State Inference (COSI) Attacks: Leaking Web Site States through XS-Leaks, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':16,'href':'/docs/attacks/experiments/','title':"Experiments",'section':"Attacks",'content':"Experiments #  This section presents XS-Leaks that affect experimental features. These features are usually hidden under a browser preference flag and its corresponding specification under active discussion. It\u0026rsquo;s important to refer these features and follow their development since the early stages to prevent XS-Leaks from happening.\n"});index.add({'id':17,'href':'/docs/attacks/historical/','title':"Historical",'section':"Attacks",'content':"Historical Attacks #  The articles in this section present XS-Leaks that were addressed within the browser and don\u0026rsquo;t work anymore. Some of the mitigations consist of:\n Reduce the accuracy of some powerful APIs. Add noise to a certain measurement to prevent any malicious inference from it. Deprecate and remove features and APIs. Change feature behavior.  "});index.add({'id':18,'href':'/docs/defenses/','title':"Defense Mechanisms",'section':"Docs",'content':"Defense Mechanisms #  Defending against all XS-Leaks Attack Vectors is not a trivial task. Each one of them affects different web and browser components and has its quirks. Some Bug Bounty programs, such as Google VRP even stopped receiving and paying for new XS-Leaks reports since they believe it\u0026rsquo;s not feasible to prepare a particular and unique bugfix for each report 1. Instead, Google and other companies believe the right approach towards fixing XS-Leaks is to invest time and human power into proposing new large scale mitigations and changes to the web platform, so that applications can use them to fix considerable chunks of XS-Leaks.\nApplication Design #  Application Design techniques allow developers to better use certain HTML APIs known to easily introduce XS-Leaks. This type of techniques helps develop temporary measures when opt in mechanisms can\u0026rsquo;t be enforced on the application right away.\nApplication Design techniques should be seen as temporary solutions, before opt in mechanisms are deployed. They are useful in particular situations, and should not be the default strategy.  Browser Default #  Browsers vendors actively discuss how to implement new mechanisms to help mitigate some of the XS-Leaks mentioned in this Wiki. They always try to make such mechanisms as transparent as possible to users and developers but this is not always possible.\nBrowser Default mechanisms can be highly effective. The biggest advantage is that it protects applications and users, and does not require extra efforts from developers.  Opt-in Mechanisms #  These Defense Mechanisms allow applications to address classes of similar XS-Leaks at once. By deploying these protections an application can instruct browsers to behave in a more secure way or it can leverage some additional information to block potential attacks.\nDeploying a combination of Opt-in Defense Mechanisms should be the default strategy. Not only they protect against XS-Leaks but also against other vulnerabilities such as XSSI, Clickjacking, CSRF, etc.  References #    Google Bughunter University - XSLeaks and XS-Search, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':19,'href':'/docs/attacks/timing-attacks/connection-pool/','title':"Connection Pool",'section':"Timing Attacks",'content':"Another way to measure the network timing of a request consists of abusing the socket pool of a browser 1. Browsers use sockets to communicate with servers and since the Operating System and the hardware it runs on have limited resources, browsers have to impose a limit.\nTo exploit the existence of this limit attackers can:\n Check what is the limit of the browser, for example 256 global sockets. Block   \\(255\\)  sockets for a long period of time (sleep) by performing  \\(255\\)  requests to different hosts. Use the  \\(256^{th}\\)  socket by performing a request to the target page. Preform a  \\(257^{th}\\)  request to another host. Since all the sockets are being used (in steps 2 and 3), this request must wait until the pool gets an available socket. This waiting period will give the attacker the network timing of the  \\(256^{th}\\)  socket, which belongs to the target page. This occurs because the  \\(255\\)  sockets in step 2. are still blocked, so if the pool got an available socket it was caused by the release of the socket in step 3. The time to release the  \\(256^{th}\\)  socket is directly connected with the time taken to complete the request.  Defense #     Same-Site Cookies Fetch Metadata COOP Framing Protections     ✔️ (if Strict) ✔️ ❌ ❌    Similarly to partitioned caches some browsers are considering to extend the principle of \u0026ldquo;split per site/origin\u0026rdquo; of resources to socket pools.  References #    Leak cross-window request timing by exhausting connection pool, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':20,'href':'/docs/attacks/historical/content-type/','title':"Content-Type",'section':"Historical",'content':"Leaking the Content-Type of a request could offer an attacker a new way to distinguish two requests from each other.\ntypeMustMatch #  typeMustMatch is a boolean that reflects the typeMustMatch attribute of the object element. It ensures a certain MIME type must be enforced when loading an object verifying if the Content-Type of the resource is the same as the one provided in the object. Unfortunately, this enforcement would allow attackers to leak the Content-Type and Status Codes returned by a website 1\nRoot Cause #  Considering the snippet below, not_loaded would be rendered if the returned Content-Type of https://target/api did not match the one in type, or the server returned a status different than 200.\n\u0026lt;object type=\u0026#34;application/json\u0026#34; data=\u0026#34;https://target.page/api\u0026#34; typemustmatch\u0026gt; not_loaded \u0026lt;/object\u0026gt; Issues #  An attacker could leak the Content-Type and Status Codes of a website by detecting whether the object rendered, which will happen when all the conditions are met. The attacker could check the values of clientHeight and clientWidth which will likely be different than 0 when the object renderers (and returned status 200). Since typeMustMatch requires the server to return status 200 to load a resource, it would be possible to detect error pages, similarly to Error Events XS-Leaks.\nThe example below shows how to detect this behavior by embedding an object inside an iframe and checking the values of clientHeight and clientWidth when the iframe triggers the onload event.\nlet url = \u0026#39;https://target.page\u0026#39; let mime = \u0026#39;application/json\u0026#39; let x = document.createElement(\u0026#39;iframe\u0026#39;); x.src = `data:text/html,\u0026lt;object id=obj type=\u0026#34;${mime}\u0026#34; data=\u0026#34;${url}\u0026#34; typemustmatch\u0026gt;\u0026lt;script\u0026gt;onload = ()=\u0026gt;{console.log(obj.clientHeight)}%3c/script\u0026gt;\u0026lt;/object\u0026gt;`; document.body.appendChild(x); Fix #  Firefox was the only browser supporting the typeMustMatch attribute 2 and since no other browsers offered support, it was removed in version 68 and from the HTML Living Standard.\nReferences #    Cross-Site Content and Status Types Leakage, link \u0026#x21a9;\u0026#xfe0e;\n Remove support for typemustmatch, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':21,'href':'/docs/defenses/browser-default/corb/','title':"Cross-Origin Read Blocking",'section':"Browser Default",'content':"Cross-Origin Read Blocking (CORB) is a browser defense mechanism that prevents attackers from loading certain cross-origin resources in unlikely scenarios 1. This protection was created to prevent speculative side-channel attacks such as Spectre which allow attackers to read the memory of their own process. CORB aims to prevent attackers from loading cross-origin contents which might contain sensitive information into an attacker-controlled process. For instance, if an attacker tries to load an HTML, XML, or JSON as an img or script tag, CORB will prevent this from happening.\nTo classify resource types CORB uses the Content-Type header if nosniff is set. In case the page does not serve a nosniff header CORB will, based on heuristics, check if the resource is worth protecting by looking at the beginning of the response body.\nChrome is the only browser with CORB deployed.  Cross-Origin Resource Policy (CORP) is an opt-in protection which enforces and extends CORB.  Considerations #  CORB introduced a new XS-Leak since attackers are able to observe whether a request was blocked or allowed by CORB. This leads to information leaks when CORB blocks certain requests depending on user information the attacker is after. However, the introduced XS-Leak has a lower impact than a Spectre exploitation of the CORB-protected resources.  References #    Cross-Origin Read Blocking for Web Developers, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':22,'href':'/docs/defenses/opt-in/coop/','title':"Cross-Origin-Opener-Policy",'section':"Opt-In",'content':"A good portion of XS-Leaks has multiple alternatives to execute the same attack, some in common with each other. For instance, some XS-Leaks abuse properties of iframes to succeed which can be fully mitigated by deploying Framing Protections. However, this same group of XS-Leaks can usually be abused by other common alternatives, that need other protections. One of those alternatives consists of opening a new window with window.open, allowing attackers to gain a reference to the opened window. With this reference an attacker can take advantage of some of its properties to perform multiple requests, ultimately inferring private information from them.\nExploiting XS-Leaks with window references is seen as the last available option mainly because the user can see it happen. However, it\u0026rsquo;s usually the right way when:\n A page sets Framing Protections A page sets Same-Site Cookies with Lax Mode (navigating a window is a top-level navigation)  To prevent untrusted origins from gaining arbitrary window references to a page, applications can deploy Cross-Origin-Opener-Policy (COOP) 1 2. With COOP, applications are in control of who is allowed to have a reference to their pages, thus mitigating XS-Leaks which make use of such techniques.\nConsiderations #  Since COOP is an opt-in mechanism and a very recent one, can be overlooked by Developers and Security Engineers. Nonetheless, it’s important to highlight the importance of this Defense Mechanism as it is the only way to prevent attackers from exploiting XS-Leaks which makes use of window references returned by APIs like window.open (unless Same-Site Cookies Strict Mode can be widely deployed).\nDeployment #  Check out this web.dev article to learn more about the advantages of this protection and how to deploy it.\nReferences #    Cross-Origin-Opener-Policy response header (also known as COOP), link \u0026#x21a9;\u0026#xfe0e;\n Cross-Origin-Opener-Policy, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':23,'href':'/docs/defenses/opt-in/corp/','title':"Cross-Origin-Resource-Policy",'section':"Opt-In",'content':"Cross-Origin-Resource-Policy (CORP) response header enforces Cross-Origin Read Blocking (CORB) as it provides more protection by covering more resources 1. Both protect against speculative side-channel attacks (Spectre) by preventing attackers from loading certain cross-origin resources in elements like script, img, video, etc. Unlike CORB, this protection is enforced in the browser only if an application opts into the protection. Applications can define which groups of origins (same-site, same-origin, cross-site) are allowed to read their resources.\nIf an application sets a certain resource CORP Header as same-site or same-origin, an attacker origin is incapable of reading that resource because is not part of the CORP group of origins.\nCross-Origin Read Blocking (CORB), a similar protection, is default browser mechanism based on heuristics to prevent attackers from loading certain cross-origin resources in unlikely scenarios.  This mechanism introduced a new XS-Leak, which allows attackers detect wether CORP was enforced in a certain request.  References #    Cross-Origin Resource Policy (CORP), link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':25,'href':'/docs/defenses/opt-in/fetch-metadata/','title':"Fetch Metadata",'section':"Opt-In",'content':"Fetch Metadata Headers are sent by browsers in every request or navigation made by a page. These Headers provide context on how every request/navigation was initiated so that applications are able to make more informed decisions on how to respond to them. This allows servers to behave differently when they detect potential attacks (e.g unexpected cross-origin requests)1. This mechanism can be very effective against cross-origin attacks like XSSI, XS-Leaks, Clickjacking, and CSRF.\nIn the scenario of XS-Leaks, servers have the ability to know when a request was made cross-origin (e.g attacker origin) and decide to answer with a response analogous to the user session. This response has no utility to the attacker since it does not carry any information or state about the user. These Headers allow the server to replicate the behavior of SameSite Cookies with fine-grained policies.\nFetch Metadata \u0026amp; Cache Probing Attacks #  Another interesting application of Fetch Metadata is its combination with the Vary Response Header, used to segregate served cached resources by groups of origins. The Vary Header when set with Sec-Fetch-Site will store and serve different cached entries based on the origin who originally performed the request. With this Header, an attacker which tries to probe a cached resource of a different origin won\u0026rsquo;t be able to interfere with cached entries created from same-origin/same-site.\nThe behavior enforced by this Header does not require major changes in the server codebase. This protection can achieve a similar protection enforced by a partitioned cache.\nConsiderations #  Fetch Metadata Headers are an in-depth Defense Mechanism and should not be seen as a replacement for mechanisms such as Same-Site Cookies, COOP or Framing Protections. Even though Fetch Metadata Headers share some capabilities with these mechanisms (e.g act differently upon cross-site requests), they do not provide a safe default. Its success is dependent on the application coverage and deployment correctness.\nDeployment #  Check out this web.dev article to learn more about the advantages of this protection and how to deploy it.\nReferences #    Protect your resources from web attacks with Fetch Metadata, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':26,'href':'/docs/defenses/opt-in/xfo/','title':"Framing Protections",'section':"Opt-In",'content':"A considerable number of XS-Leaks relies on some properties of frames. If an attacker is unable to embed the contents of a page as an iframe, frame, embed or object then the attack may no longer be possible. To mitigate XS-Leaks which rely on these objects, pages can forbid or select which origins can embed them. This is possible by using the X-Frame-Options Header or the CSP frame-ancestors directive.\nSince a website enforcing Framing Protections can\u0026rsquo;t be embedded from an attacker origin, the website is not rendered and the JavaScript does not run. Therefore, all of its subresources (images, JS or CSS) are not retrieved by the browser.\nX-Frame-Options Header is obsolete and was replaced by the CSP frame-ancestors directive.  Considerations #  This protection is very effective against XS-Leaks which rely on iframes and can be easily implemented without breaking the vast majority of applications. This mechanism not only protects from some XS-Leaks but also attacks like Clickjacking.\nDeployment #  Deploying framing protections is usually straightforward as many applications do not require to be embedded cross-origin in an iframe. Check out this web.dev article to learn more about the advantages of this header.\n"});index.add({'id':27,'href':'/docs/defenses/browser-default/partitioned-cache/','title':"Partitioned HTTP Cache",'section':"Browser Default",'content':"Cache probing attacks have been present on the web for a long time mainly because browsers HTTP cache is shared across all the websites visited by a user, allowing attackers to interact with it and infer private information from other origins.\nConsidering Opt-in solutions, applications can use the Vary Header combined with Fetch-Metadata to prevent cross-origin fetches to be affected by the site cache or use some workarounds to protect resources, which come with downsides. Browsers, however, have been planning a defense mechanism to segregate the cached resources per origin/site, making it impossible for attackers pages to interact with cached contents of different origins 1 2 3. Specifically, browsers tested caching with finer-grained keys such as the tuple \u0026lt;top-frame origin, URL\u0026gt; or even triples of values.\nChrome 1 and Firefox 2 are still discussing an implementation for a Multi-Keyed Cache while Safari 3 already runs a version of it since 2013.\n  Split Disk Cache Meta Bug (Blink), link \u0026#x21a9;\u0026#xfe0e;\n Top-level site partitioning (Gecko), link \u0026#x21a9;\u0026#xfe0e;\n Optionally partition cache to prevent using cache for tracking (Webkit), link \u0026#x21a9;\u0026#xfe0e;\n    Relevant Projects #  WebKit Tracking Prevention Technologies #  Safari implements a partitioned HTTP Cache which originated from the initial WebKit Keyed cache from 2013, now part of WebKit Tracking Prevention technologies. The used keys for the cache are the top frame\u0026rsquo;s eTLD+1 and the origin of each fetched subresource.\nFirst Party Isolation #  First Party Isolation is a Browser Extension for Firefox which restricts access to cookies and persistent data (e.g cache) per domain.\nConsiderations #  Partitioned HTTP caches are a promising security feature that will eventually land in browsers. These partitioning strategies will mitigate all the XS-Leaks leveraging browsers caches and might be extended to other browser resources which help mitigate resilient attack vectors like the Socket Exhaustion XS-Leak.\nReferences #    Double-keyed HTTP cache, link \u0026#x21a9;\u0026#xfe0e;\n Explainer - Partition the HTTP Cache, link \u0026#x21a9;\u0026#xfe0e;\n Client-Side Storage Partitioning, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':28,'href':'/docs/attacks/experiments/portals/','title':"Portals",'section':"Experiments",'content':"Portals are a new feature of the web similar to iframes with more emphasis on speed and user experience. The portal element is only available on Chromium-based browsers under a preference flag. The corresponding specification is still under active discussion.\nUnfortunately, some research over this new feature found critical issues, including new XS-Leaks 1.\nID Leaks #  Portals can be abused as an alternative for the ID Attribute XS-Leak. If the website sets framing protections, the same technique can be applied using the portal element instead 2.\nReferences #    Security analysis of \u0026lt;portal\u0026gt; element, link \u0026#x21a9;\u0026#xfe0e;\n Detecting IDs using Portal, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':29,'href':'/docs/defenses/opt-in/same-site-cookies/','title':"Same-Site Cookies",'section':"Opt-In",'content':"Same-Site Cookies are one of the most impactful Security Mechanisms towards fixing security issues that involve cross-site requests. This mechanism allows applications to add a new attribute to cookies, forcing browsers to only append them in requests that are issued same-site 1. This type of cookies has two modes: Lax and Strict.\nLax V.s Strict #  The only difference between Lax and Strict is that Lax mode allows cookies to be added to requests triggered by top-level navigations. If bank.com sets Same-Site=Lax and attacker.com makes a request using the fetch API cookies won\u0026rsquo;t be sent. bank.com, instead, is allowed to make requests to itself since they are same-site. Unfortunately, if the attacker navigates the user with window.open (which triggers a top-level navigation) the cookies will be sent and the attacker would have a reference to that window, making them able to exploit some XS-Leaks.\nConsiderations #  Same-Site Cookies are not bulletproof 2 nor they can fix everything. To complete the defense strategy against XS-Leaks users should consider implementing other protections, for instance, to stop an attacker from controlling pages using a window reference even if Same-Site Cookies (Lax) are in use.\nDeployment #  Anyone interested in deploying this mechanism in web applications should take a careful look at this web.dev article.\nReferences #    SameSite cookies explained, link \u0026#x21a9;\u0026#xfe0e;\n Bypass SameSite Cookies Default to Lax and get CSRF link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':30,'href':'/docs/attacks/experiments/scroll-to-text-fragment/','title':"Scroll to Text Fragment",'section':"Experiments",'content':"Scroll to Text Fragment (STTF) is a new web platform feature that allows users to create a link to any part of a web page text. The fragment #:~:text= carries a text snippet that is highlighted and brought into the viewport by the browser. This feature can introduce a new XS-Leak if attackers are able to detect when this behavior occurs. This issue is very similar to the Scroll to CSS Selector XS-Leak.\nExpected \u0026amp; Discussed Issues #  In early discussions for the specification of this feature it was showed several XS-Leaks could be introduced with a naïve implementation 1. The specification considers various attack scenarios 2, so does some research from Google 3. This is one possible XS-Leak browsers would need to be aware of when implementing this feature:\n An attacker can, by embedding a page as an iframe, detect whether the page scrolled to the text by listening to the onblur of the parent document. This approach is similar to the ID Attribute XS-Leak. This scenario is mitigated in the Chrome implementation 4 as it only allows the fragment navigation to occur in top-level navigations.  Current Issues #  These XS-Leaks require some type of markup injection on the target page.  During the development process of STTF new attacks and tricks to detect a fragment navigation were found. Some of them still work:\n A web page that embeds an attacker-controlled iframe might allow the attacker to determine whether a scroll to the text has occurred. This can be done using the IntersectionObserver API 5 2 3. If a page contains images with Lazy Loading an attacker might known if a fragment navigation that included an image occurred by checking whether it was cached in the browser. This occurs because Lazy Loading images are only fetched (and cached) when they appear in the viewport.  Scroll to Text Fragment is only available in Chrome. Its draft specification is under active discussion.  Scroll to Text Fragment XS-Leaks allow attackers to extract 1 bit of information at a time as it\u0026rsquo;s only possible to observe whether a group of words is present in a page. This occurs as STTF matching mechanism is based on words, so attackers won\u0026rsquo;t be able to leak information character by character.  Why is this a problem? #  Attackers can abuse STTF to leak private information about the user since its highly connected with the contents of a web page.\nCase Scenarios #   A user is logged in its National Health System website, where it is possible to access information about the user past diseases and health problems. An attacker can lure the user to one of its pages and use STTF to possibly infer specific deceases of the user. For example an attacker would find out if the victim suffers of a disease if they detects a page scroll when searching for that pathology name.  Defense #     Attack Alternative Same-Site Cookies Fetch Metadata COOP Framing Protections     IntersectionObserver (iframes) ❌ ❌ ❌ ❌   Lazy Loading ✔️ ✔️ ❌ ❌    References #    Privacy concerns with proposal through inducing network requests, link \u0026#x21a9;\u0026#xfe0e;\n Text Fragments - Security and Privacy, link \u0026#x21a9;\u0026#xfe0e;\n Scroll-to-text Fragment Navigation - Security Issues, link \u0026#x21a9;\u0026#xfe0e;\n Boldly link where no one has linked before: Text Fragments, link \u0026#x21a9;\u0026#xfe0e;\n Possible side-channel information leak using IntersectionObserver, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':31,'href':'/docs/attacks/historical/stateful-browser-features/','title':"Stateful Browser Features",'section':"Historical",'content':"Some browser features/extensions change the way requests are processed depending on certain website states generated by the browser. Attackers can sometimes observe the whole process and mess with the browser, triggering actions that produce side-effects on those states.\nWebKit - ITP #  Intelligent Tracking Prevention (ITP) is a privacy feature part of WebKit Tracking Prevention technologies. It’s a conjunction of several features to prevent a website from tracking a user under a third-party context. Unfortunately, the initial design introduced a new XS-Leak 1, allowing attackers to abuse the states implicitly created by ITP to classify websites as trackers.\nRoot Cause #  To classify whether a website had tracking capabilities, ITP collects statistics on resource loads as well as user interactions in websites such as clicks, taps, or text entries. Based on the classification of these statistics, ITP gives a strike to a website if it is believed to have tracking capabilities. After 3 strikes a website is put on a deny list and have a different treatment by the browser in certain requests.\nIssues #  One of the issues of ITP is that attackers can interact with it to arbitrarily enforce certain behaviors. For example, one could force ITP to give a strike to a domain and check if the domain entered the deny list. Some of the attacks leveraging ITP consist in:\n Checking if a website enters the deny list, or how many strikes left are needed to put a website on the deny list may allow an attacker to discover user\u0026rsquo;s browsing habits. An attacker could attack a Search System with XS-Search if it includes any cross-site resource when results are present, but omits that same resource when no results are found. Attackers could force ITP to give 2 strikes to the cross-site resource and, after triggering a request to the search system, check if the resource was put in the deny list.  Fix #  To fix the issue, instead of relying on classifications, ITP now considers every site as a \u0026ldquo;tracking\u0026rdquo; one by default. This removes the implicit states which allowed attackers to detect certain ITP behaviors.\nReferences #    Information Leaks via Safari’s Intelligent Tracking Prevention, link \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':32,'href':'/docs/defenses/design-protections/subresource-protections/','title':"Subresource Protections",'section':"Application Design",'content':"Random tokens #  One of the principles of protecting subresources is the same as protecting endpoints from CSRF attacks. The difference from CSRF protections is that in the case of XS-Leaks, GET requests are the ones usually worth protecting. To apply this protection applications can append a (cryptographically strong) pseudorandom value, unique to each request/session, to make the URL of a subresource unpredictable to an attacker. The protection can be applied to the following types of subresources:\n Authenticated subresources such as API endpoints or regular authenticated URLs. While pseudorandom values can be used in this case, security mitigations like Same-Site Cookies can be cheaper to deploy and more effective. Unauthenticated subresources such as images can use this protection to prevent some types of Cache Probing Attacks. In this scenario, this protection can be highly effective but it might hinder cache efficacy or be otherwise hard to deploy.  User Consent #  Some applications might ask for user consent to trigger a certain sensitive action. Facebook deploys this protection in some sensible search endpoints like https://www.facebook.com/messages/?qa=UserMustConsent, where a user musk press OK to advance with the search query. Since attackers can\u0026rsquo;t surpass this verification, the page won\u0026rsquo;t leak any special behavior.\nUser consent is often asked in applications to warn the user it\u0026rsquo;s being redirected to a website outside of the current website. This prevents attackers to detect some type of navigations.\nDeployment #  While this protection might work in some scenarios, it has some disadvantages:\n Hard to deploy as it requires substantial changes in the codebase. It might break the desired behavior for the feature. In the case of random tokens, it will break bookmarks and other permanent references. Consent pages might add friction to using the application.  This protection can be enough to fix attacks temporarily in certain scenarios. Due to the challenges of deploying this protection, applications are encouraged to deploy opt-in web platform security features as the default approach.  "});})();
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Attack on XS-Leaks Wiki</title><link>https://xsleaks.com/category/attack/</link><description>Recent content in Attack on XS-Leaks Wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://xsleaks.com/category/attack/index.xml" rel="self" type="application/rss+xml"/><item><title>XS-Search</title><link>https://xsleaks.com/docs/attacks/xs-search/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/xs-search/</guid><description>Cross-Site Search (XS-Search) is an important attack and principle in the family of XS-Leaks. The attack abuses Query-Based Search Systems to leak user information from an attacker origin 1 2. The original attack used timing measurements to detect when a search system returned results or no results and works as follows:
Establish a baseline time for a request returning results (hit) and a baseline for a request with no results (miss).</description></item><item><title>CORB Leaks</title><link>https://xsleaks.com/docs/attacks/browser-features/corb/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/browser-features/corb/</guid><description>Cross-Origin Read Blocking (CORB) is a web platform security feature aimed at reducing the impact of speculative side-channel attacks such as Spectre. Unfortunately blocking certain types of requests introduced a new type of XS-Leaks, allowing attackers to detect if CORB was enforced in one request, but wasn&amp;rsquo;t on another. Nevertheless, the introduced XS-Leaks are much less problematic than the issues actively protected by CORB (e.g Spectre).
CORB &amp;amp; Error Events # Attackers can observe when CORB is enforced if a response returns a CORB protected Content-Type (and nosniff) with status code 2xx which results in CORB stripping the body and Headers from the response.</description></item><item><title>CORP Leaks</title><link>https://xsleaks.com/docs/attacks/browser-features/corp/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/browser-features/corp/</guid><description>Explanation # Cross-Origin Resource Policy (CORP) is a web platform security feature which enforces CORB. Unfortunately, similarly to CORB XS-Leak applications can introduce a new XS-Leak if they misconfigure the use of this protection.
A webpage will introduce an XS-Leak if CORP is enforced based on user data. If a page search feature enforces CORP when showing results, but doesn&amp;rsquo;t when returning no results, an attacker will be able to distinguish the two scenarios.</description></item><item><title>Error Events</title><link>https://xsleaks.com/docs/attacks/error-events/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/error-events/</guid><description>When a webpage issues a request to a server (e.g fetch, HTML tags), this request will be received and processed by that server. When received the server will decide whether the request should succeed (e.g 200) or fail (e.g 404) based on the provided context. When a response has an error status an error event will be fired by the browser for the page to handle. These errors are also extended to situations where the parser fails, for example, trying to embed HTML content as an image.</description></item><item><title>Frame Counting</title><link>https://xsleaks.com/docs/attacks/frame-counting/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/frame-counting/</guid><description>Window references allow cross-origin pages to get access to some attributes of other pages. These references become available when using or allowing iframe and window.open. They provide some information (although limited) about the window as they still respect the Same Origin Policy.
One of the accessible attributes is window.length which provides the number of frames in the window. This attribute can give valuable information about a page to an attacker.</description></item><item><title>Navigations</title><link>https://xsleaks.com/docs/attacks/navigations/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/navigations/</guid><description>Detecting if a cross-site page triggered a navigation (or didn&amp;rsquo;t) can be useful to an attacker. For example, a website may trigger a navigation in a certain endpoint depending on the status of the user.
To detect if any kind of navigation occurred, an attacker can:
Use an iframe and count the number of times the onload event is triggered. Check the value of History.length, accessible through any window reference.</description></item><item><title>Network Timing</title><link>https://xsleaks.com/docs/attacks/timing-attacks/network-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/network-timing/</guid><description>Network Timing side-channels have been present on the web since its beginning 1 2. These attacks achieved different levels of impact over time, gaining new attention when browsers started shipping high precision timers like performance.now().
To obtain timing measurements attackers must use a clock, either an implicit or explicit one. These clocks are usually interchangeable and only vary in accuracy and availability. For simplicity, this article will only address the performance.</description></item><item><title>Cache Probing</title><link>https://xsleaks.com/docs/attacks/cache-probing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/cache-probing/</guid><description>The principle of Cache Probing consists of detecting whether some resource was cached by the browser. The concept is known since the begging of the web 1 and initially used timing differences to succeed.
When a user visits a website some resources such as images, scripts, and HTML content are fetched and later cached by the browser (under certain conditions). This optimization will make future navigations faster as the browser will serve those resources from disk instead of requesting them again.</description></item><item><title>Execution Timing</title><link>https://xsleaks.com/docs/attacks/timing-attacks/execution-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/execution-timing/</guid><description>Measuring the time of JavaScript execution in a browser can give attackers information on when certain events are triggered, and how long some operations take.
Timing the Event Loop # JavaScript concurrency model is based on a single-threaded event loop which means it can only run one task at a time. If, for example, some time-consuming task blocks the event loop, the user can perceive a freeze on a page as a result of the UI thread being starved.</description></item><item><title>Hybrid Timing</title><link>https://xsleaks.com/docs/attacks/timing-attacks/hybrid-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/hybrid-timing/</guid><description>Hybrid Timing Attacks allow attackers to measure a combination of factors that influence the final timing measurement. These factors can be:
Network. Parsing. Retrieve and load subresources. Execution. Some of the factors differ in value depending on the application. This means that Network Timing might be more observable in pages with more backend processing while Execution Timing can be more observable in applications processing and displaying data within the browser.</description></item><item><title>ID Attribute</title><link>https://xsleaks.com/docs/attacks/id-attribute/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/id-attribute/</guid><description>The id attribute is widely used to identify some HTML elements. Unfortunately, these ids can be leaked by leveraging the focus event and the URL fragment. For example, some web applications set id attributes in focusable elements that may lead to user information disclosure. These ids can either be direct information related to the user (e.g a secret) or information associated with a user state (e.g account status). There are two alternatives to complete this attack:</description></item><item><title>postMessage Broadcasts</title><link>https://xsleaks.com/docs/attacks/postmessage-broadcasts/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/postmessage-broadcasts/</guid><description>Applications often use postMessage broadcasts to provide information to any interested origin. Apart from the obvious security issues (providing sensitive information to any origin), other problems might occur if a legitimate postMessage broadcast is not properly implemented 1.
If a broadcast happens based on user information, attackers might be able to leak information if they can distinguish two scenarios. There are multiple ways applications can be inconsistent with broadcast:
An application sends different broadcasted messages.</description></item><item><title>Connection Pool</title><link>https://xsleaks.com/docs/attacks/timing-attacks/connection-pool/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/connection-pool/</guid><description>Another way to measure the network timing of a request consists of abusing the socket pool of a browser 1. Browsers use sockets to communicate with servers and since the Operating System and the hardware it runs on have limited resources, browsers have to impose a limit.
To exploit the existence of this limit attackers can:
Check what is the limit of the browser, for example 256 global sockets. Block \(255\) sockets for a long period of time (sleep) by performing \(255\) requests to different hosts.</description></item></channel></rss>
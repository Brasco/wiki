<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on XS-Leaks Wiki</title><link>https://xsleaks.dev/</link><description>Recent content in Introduction on XS-Leaks Wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://xsleaks.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Clocks</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/clocks/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/clocks/</guid><description>We can distinguish two types of clocks - Explicit and Implicit. Explicit clocks are the ones developers use to get direct timing measurements and such mechanisms are offered explicitly by the browser. Implicit clocks on the other hand, utilise particular web features to create unintended clocks that allow measuring the relative passage of time.
Explicit Clocks # performance.now API # The performance.now() API allows developers to get high-resolution timing measurements.</description></item><item><title>XS-Search</title><link>https://xsleaks.dev/docs/attacks/xs-search/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/xs-search/</guid><description>Cross-Site Search (XS-Search) is an important attack and principle in the family of XS-Leaks. The attack abuses Query-Based Search Systems to leak user information from an attacker origin 1 2. The original attack used timing measurements to detect whether or not a search system returned results and works as follows:
Establish a baseline time for a request returning results (hit) and a baseline for a request with no results (miss).</description></item><item><title>CORB Leaks</title><link>https://xsleaks.dev/docs/attacks/browser-features/corb/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/browser-features/corb/</guid><description>Cross-Origin Read Blocking (CORB) is a web platform security feature aimed at reducing the impact of speculative side-channel attacks such as Spectre. Unfortunately, blocking certain types of requests introduced a new type of XS-Leaks that allows attackers to detect if CORB was enforced on one request, but wasn&amp;rsquo;t on another. Nevertheless, the introduced XS-Leaks are much less problematic than the issues actively protected by CORB (e.g Spectre).
CORB &amp;amp; Error Events # Attackers can observe when CORB is enforced if a response returns a CORB protected Content-Type (and nosniff) with status code 2xx which results in CORB stripping the body and headers from the response.</description></item><item><title>CORP Leaks</title><link>https://xsleaks.dev/docs/attacks/browser-features/corp/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/browser-features/corp/</guid><description>Explanation # Cross-Origin Resource Policy (CORP) is a web platform security feature that allows websites to prevent certain resources from being loaded by other origins. This protection complements CORB since it is an opt-in defense whereas CORB blocks some cross-origin reads by default. Unfortunately, similarly to CORB applications can introduce a new XS-Leak if they misconfigure the use of this protection.
A webpage will introduce an XS-Leak if CORP is enforced based on user data.</description></item><item><title>Error Events</title><link>https://xsleaks.dev/docs/attacks/error-events/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/error-events/</guid><description>When a webpage issues a request to a server (e.g fetch, HTML tags), this request will be received and processed by that server. When received the server will decide whether the request should succeed (e.g 200) or fail (e.g 404) based on the provided context. When a response has an error status an error event will be fired by the browser for the page to handle. These errors are also extended to situations where the parser fails, for example, trying to embed HTML content as an image.</description></item><item><title>Frame Counting</title><link>https://xsleaks.dev/docs/attacks/frame-counting/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/frame-counting/</guid><description>Window references allow cross-origin pages to get access to some attributes of other pages. These references become available when using or allowing iframe and window.open. They provide some information (although limited) about the window as they still respect the Same Origin Policy.
One of the accessible attributes is window.length which provides the number of frames in the window. This attribute can give valuable information about a page to an attacker.</description></item><item><title>Navigations</title><link>https://xsleaks.dev/docs/attacks/navigations/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/navigations/</guid><description>Detecting if a cross-site page triggered a navigation (or didn&amp;rsquo;t) can be useful to an attacker. For example, a website may trigger a navigation in a certain endpoint depending on the status of the user.
To detect if any kind of navigation occurred, an attacker can:
Use an iframe and count the number of times the onload event is triggered. Check the value of history.length, accessible through any window reference.</description></item><item><title>Network Timing</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/</guid><description>Network Timing side-channels have been present on the web since its beginning 1 2. These attacks have had different levels of impact over time, gaining new attention when browsers started shipping high precision timers like performance.now().
To obtain timing measurements attackers must use a clock, either an implicit or explicit one. These clocks are usually interchangeable for the purposes of XS-Leaks and only vary in accuracy and availability. For simplicity, this article will assume use of the performance.</description></item><item><title>Cache Probing</title><link>https://xsleaks.dev/docs/attacks/cache-probing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/cache-probing/</guid><description>The principle of Cache Probing consists of detecting whether some resource was cached by the browser. The concept is known since the beginning of the web 1 and initially relied on detecting timing differences.
When a user visits a website some resources such as images, scripts, and HTML content are fetched and later cached by the browser (under certain conditions). This optimization will make future navigations faster as the browser will serve those resources from disk instead of requesting them again.</description></item><item><title>Execution Timing</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/</guid><description>Measuring the time of JavaScript execution in a browser can give attackers information on when certain events are triggered, and how long some operations take.
Timing the Event Loop # JavaScript&amp;rsquo;s concurrency model is based on a single-threaded event loop which means it can only run one task at a time. If, for example, some time-consuming task blocks the event loop, the user can perceive a freeze on a page as a result of the UI thread being starved.</description></item><item><title>Hybrid Timing</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/hybrid-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/hybrid-timing/</guid><description>Hybrid Timing Attacks allow attackers to measure the sum of a bunch of factors that influence the final timing measurement. These factors include:
Network delays Document parsing Retrieval and processing of subresources Code execution Some of the factors differ in value depending on the application. This means that Network Timing might be more significant in pages with more backend processing while Execution Timing can be more significant in applications processing and displaying data within the browser.</description></item><item><title>ID Attribute</title><link>https://xsleaks.dev/docs/attacks/id-attribute/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/id-attribute/</guid><description>The id attribute is widely used to identify some HTML elements. Unfortunately, cross-origin websites can determine whether a given id is set anywhere on the page by leveraging the focus event and URL fragments. If https://example.com/foo#bar is loaded, the browser will attempt to scroll to the element with id=&amp;quot;bar&amp;quot;. This can be detected cross-origin by loading https://example.com/foo#bar in an iframe and if there is an element with id=&amp;quot;bar&amp;quot; then the focus event will fire.</description></item><item><title>postMessage Broadcasts</title><link>https://xsleaks.dev/docs/attacks/postmessage-broadcasts/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/postmessage-broadcasts/</guid><description>Applications often use postMessage broadcasts to share information with other origins. postMessage can lead to two kinds of XS-Leaks:
Sensitive messages shared with untrusted origins
The postMessage API supports a targetOrigin parameter that can be used to restrict which origins can receive the message. If the message contains any sensitive data, it is important to use this parameter. Leaking information based on different content or on the presence of a broadcast</description></item><item><title>Cache Protections</title><link>https://xsleaks.dev/docs/defenses/design-protections/cache-protections/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/design-protections/cache-protections/</guid><description>There are a number of different approaches applications can use to defend against cache probing-based XS-Leaks. These approaches are explained in the following sections.
Cache Protection via Cache-Control Headers # If it is acceptable to disable caching, doing so provides a strong defense against cache probing attacks. Disabling caching means that every time someone loads a resource, the resource has to be fetched again. To disable caching, set a Cache-Control: no-store header on every single response that you wish to protect.</description></item><item><title>Connection Pool</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/</guid><description>Another way to measure the network timing of a request consists of abusing the socket pool of a browser 1. Browsers use sockets to communicate with servers and since the Operating System and the hardware it runs on have limited resources, browsers have to impose a limit.
To exploit the existence of this limit attackers can:
Check what is the limit of the browser, for example 256 global sockets. Block \(255\) sockets for a long period of time by performing \(255\) requests to different hosts that simply hang the connection Use the \(256^{th}\) socket by performing a request to the target page.</description></item><item><title>Content-Type</title><link>https://xsleaks.dev/docs/attacks/historical/content-type/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/historical/content-type/</guid><description>Leaking the Content-Type of a request could offer an attacker a new way to distinguish two requests from each other.
typeMustMatch # typeMustMatch is a boolean that reflects the typeMustMatch attribute of the object element. It ensures a certain MIME type must be enforced when loading an object verifying if the Content-Type of the resource is the same as the one provided in the object. Unfortunately, this enforcement would allow attackers to leak the Content-Type and Status Codes returned by a website 1</description></item><item><title>Cross-Origin Read Blocking</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</guid><description>Cross-Origin Read Blocking (CORB) is a security mechanism that prevents attackers from loading certain cross-origin resources 1. This protection was created to defend against speculative side-channel attacks such as Spectre that allow attackers to read the memory of the process that both cross-site pages (e.g. attacker.com and sensitive.com) were embedded into. CORB aims to prevent attackers from loading certain sensitive cross-origin resources into an attacker-controlled process. For example, if an attacker tries to load cross-origin HTML, XML, or JSON into an img tag, CORB prevents this from happening.</description></item><item><title>Cross-Origin-Opener-Policy</title><link>https://xsleaks.dev/docs/defenses/opt-in/coop/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/coop/</guid><description>Getting access to a website&amp;rsquo;s window object is a common prerequisite for different XS-Leak techniques. Framing Protections can ensure that an attacker cannot use iframes to access the window object, but this does not stop an attacker from accessing it from an opened window through window.open(url) or window.opener references.
Exploiting XS-Leaks with window.open is generally seen as the least appealing option for an attacker because the user can see it happen in the open browser window.</description></item><item><title>Cross-Origin-Resource-Policy</title><link>https://xsleaks.dev/docs/defenses/opt-in/corp/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/corp/</guid><description>Cross-Origin Resource Policy (CORP) is a web platform security feature that allows websites to prevent certain resources from being loaded by other origins. This protection complements CORB since it is an opt-in defense whereas CORB blocks some cross-origin reads by default. It is designed to protect against both speculative execution attacks and XS-Leaks by allowing developers to ensure that sensitive resources cannot end up in attacker controlled processes. Unlike CORB, this protection is enforced in the browser only if an application opts in to the protection.</description></item><item><title>Fetch Metadata</title><link>https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/</guid><description>Fetch metadata headers are sent by browsers with HTTP requests. These headers provide context on how a request was initiated so that applications are able to make more informed decisions on how to respond to them. This allows servers to behave differently when they detect potential attacks (e.g. unexpected cross-origin requests)1. This can be very effective against cross-origin attacks like XSSI, XS-Leaks, Clickjacking, and CSRF if a strict policy is deployed on the server.</description></item><item><title>Framing Protections</title><link>https://xsleaks.dev/docs/defenses/opt-in/xfo/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/xfo/</guid><description>A considerable number of XS-Leaks relies on some properties of iframes. If an attacker is unable to embed the contents of a page as an iframe, frame, embed or object then the attack may no longer be possible. To mitigate XS-Leaks which rely on these objects, pages can forbid or select which origins can embed them. This is possible by using the X-Frame-Options Header or the CSP frame-ancestors directive.
Since a website enforcing Framing Protections can&amp;rsquo;t be embedded from an attacker origin, the website is not rendered and the JavaScript does not run.</description></item><item><title>Partitioned HTTP Cache</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</guid><description>In order to defend against cache probing attacks, browser developers are actively working on implementing a partitioned HTTP cache functionality that would in essence ensure each website has a distinct cache. Since cache probing relies on the fact that a browser&amp;rsquo;s HTTP cache is shared across every website, a partitioned HTTP cache can defend against many cache probing techniques. This is done by using tuples (either (top-frame-site, resource-url) or (top-frame-site, framing-site, resource-url)) as the cache keys to ensure the cache is partitioned by the requesting site.</description></item><item><title>Portals</title><link>https://xsleaks.dev/docs/attacks/experiments/portals/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/experiments/portals/</guid><description>Portals are a new feature of the web similar to iframes with more emphasis on speed and user experience. The portal element is only available on Chromium-based browsers under a preference flag. The corresponding specification is still under active discussion.
Unfortunately, some research over this new feature found critical issues, including new XS-Leaks 1.
ID Leaks # Portals can be abused as an alternative for the ID Attribute XS-Leak. If the website sets framing protections, the same technique can be applied using the portal element instead 2.</description></item><item><title>Same-Site Cookies</title><link>https://xsleaks.dev/docs/defenses/opt-in/same-site-cookies/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/same-site-cookies/</guid><description>SameSite cookies are one of the most impactful modern security mechanisms for fixing security issues that involve cross-site requests. This mechanism allows applications to force browsers to only include cookies in requests that are issued same-site 1. This type of cookie has three modes: None, Lax, and Strict.
Same-Site Cookie Modes # The following SameSite cookie modes are available:
None – Disables all protections and restores the old behavior of cookies.</description></item><item><title>Scroll to Text Fragment</title><link>https://xsleaks.dev/docs/attacks/experiments/scroll-to-text-fragment/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/experiments/scroll-to-text-fragment/</guid><description>Scroll to Text Fragment (STTF) is a new web platform feature that allows users to create a link to any part of a web page text. The fragment #:~:text= carries a text snippet that is highlighted and brought into the viewport by the browser. This feature can introduce a new XS-Leak if attackers are able to detect when this behavior occurs. This issue is very similar to the Scroll to CSS Selector XS-Leak.</description></item><item><title>Stateful Browser Features</title><link>https://xsleaks.dev/docs/attacks/historical/stateful-browser-features/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/historical/stateful-browser-features/</guid><description>Some browser features/extensions change the way requests are processed depending on certain website states generated by the browser. Attackers can sometimes observe the whole process and mess with the browser, triggering actions that produce side-effects on those states.
WebKit - ITP # Intelligent Tracking Prevention (ITP) is a privacy feature part of WebKit Tracking Prevention technologies. It’s a conjunction of several features to prevent a website from tracking a user under a third-party context.</description></item><item><title>Subresource Protections</title><link>https://xsleaks.dev/docs/defenses/design-protections/subresource-protections/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/design-protections/subresource-protections/</guid><description>The fundamental idea behind designing protections for subresources is that subresources cannot be targeted by XS-Leaks if the attacker cannot make them return any user data. If implemented correctly, this approach can be a very strong defense, though it is likely to be tough to implement and could negatively impact the user experience.
It can be very effective to deploy this approach on any specific resources that are known to be especially sensitive to XS-Leaks.</description></item></channel></rss>
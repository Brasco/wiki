<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on XS-Leaks Wiki</title><link>https://xsleaks.com/</link><description>Recent content in Introduction on XS-Leaks Wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://xsleaks.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Clocks</title><link>https://xsleaks.com/docs/attacks/timing-attacks/clocks/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/clocks/</guid><description>We can distinguish two types of clocks - Explicit and Implicit. Explicit clocks are the ones developers use to get direct timing measurements and such mechanisms are offered explicitly by the browser. Implicit clocks on the other hand, misuse particular web features to create unintended clocks which offer a relative timing.
Explicit Clocks # performance.now API # The performance.now() API allows developers to get high-resolution timing measurements.
performance.now() API got its accuracy reduced from a range of nanoseconds to a microsecond precision in all modern browsers, to mitigate some XS-Leaks 1 2 3.</description></item><item><title>Connection Pool</title><link>https://xsleaks.com/docs/attacks/timing-attacks/connection-pool/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/connection-pool/</guid><description>Another way to measure the network timing of a request consists of abusing the socket pool of a browser 1. Browsers use sockets to communicate with servers and since the Operating System and the hardware it runs on have limited resources, browsers have to impose a limit.
To exploit the existence of this limit attackers can:
Check what is the limit of the browser, for example 256 global sockets. Block \(255\) sockets for a long period of time (sleep) by performing \(255\) requests to different hosts.</description></item><item><title>CORB Leaks</title><link>https://xsleaks.com/docs/attacks/corb/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/corb/</guid><description>Cross-Origin Read Blocking (CORB) is a web platform security feature aimed at reducing the impact of speculative side-channel attacks such as Spectre. Unfortunately blocking certain types of requests introduced a new type of XS-Leaks, allowing attackers to detect if CORB was enforced in one request, but wasn&amp;rsquo;t on another. Nevertheless, the introduced XS-Leaks are much less problematic than the issues actively protected by CORB (e.g Spectre).
CORB &amp;amp; Error Events # Attackers can observe when CORB is enforced if a response returns a CORB protected Content-Type (and nosniff) with status code 2xx which results in CORB stripping the body and headers from the response.</description></item><item><title>CORP Leaks</title><link>https://xsleaks.com/docs/attacks/corp/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/corp/</guid><description>Explanation # Cross-Origin Resource Policy (CORP) is a web platform security feature which enforces CORB. Unfortunately, similarly to CORB XS-Leak applications can introduce a new XS-Leak if they misconfigure the use of this protection.
A webpage will introduce an XS-Leak if CORP is enforced based on user data. If a page search feature enforces CORP when showing results, but doesn&amp;rsquo;t when returning no results, an attacker will be able to distinguish the two scenarios.</description></item><item><title>Cross-Origin Read Blocking</title><link>https://xsleaks.com/docs/defenses/browser-intrinsic/corb/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/browser-intrinsic/corb/</guid><description>Explanation # Cross-Origin Read Blocking (CORB) is a browser defense mechanism that prevents attackers from loading certain cross-origin resources in unlikely scenarios 1. This protection was created to prevent speculative side-channel attacks such as Spectre which allow attackers to read the memory of their own process. CORB aims to prevent attackers from loading cross-origin contents which might contain sensitive information into an attacker-controlled process. For instance, if an attacker tries to load an HTML, XML, or JSON as an img or script tag, CORB will prevent this from happening.</description></item><item><title>Cross-Origin-Opener-Policy</title><link>https://xsleaks.com/docs/defenses/opt-in/coop/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/opt-in/coop/</guid><description>Explanation # A good portion of XS-Leaks has multiple alternatives to execute the same attack, some in common with each other. For instance, some XS-Leaks abuse properties of iframes to succeed which can be fully mitigated by deploying Framing Protections. However, this same group of XS-Leaks can usually be abused by other common alternatives, that need other protections. One of those alternatives consists of navigating the user away using window.</description></item><item><title>Cross-Origin-Resource-Policy</title><link>https://xsleaks.com/docs/defenses/opt-in/corp/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/opt-in/corp/</guid><description>Cross-Origin-Resource-Policy (CORP) response header enforces Cross-Origin Read Blocking (CORB) as it provides more protection by covering more resources 1. Both protect against speculative side-channel attacks (Spectre) by preventing attackers from loading certain cross-origin resources in elements like script, img, video, etc. Unlike CORB, this protection is enforced in the browser only if an application opts into the protection. Applications can define which groups of origins (same-site, same-origin, cross-site) are allowed to read their resources.</description></item><item><title>Defensive Design</title><link>https://xsleaks.com/docs/defenses/design-protections/defensive-design/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/design-protections/defensive-design/</guid><description>This section should focus on defensive design techniques to prevent XS-Leaks from happening. Some ideas:
The way applications use iframes to display information based on a user query (search system) How applications use Fetch Metadata with Vary headers to prevent cache probing attacks and what problems might occur with improper deployments. Are there any drawbacks of deploying this? How to ensure all application endpoints implement certain Headers to have the same behavior across different states.</description></item><item><title>Error Events</title><link>https://xsleaks.com/docs/attacks/error-events/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/error-events/</guid><description>When a webpage issues a request to a server (e.g fetch, HTML tags), this request will be received and processed by that server. When received the server will decide whether the request should succeed (e.g 200) or fail (e.g 404) based on the provided context. When a response has an error status an error event will be fired by the browser for the page to handle. These errors are also extended to situations where the parser fails, for example, trying to embed HTML content as an image.</description></item><item><title>Execution Timing</title><link>https://xsleaks.com/docs/attacks/timing-attacks/execution-timing/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/execution-timing/</guid><description>Measuring the time of JavaScript execution in a browser can give attackers information on when certain events are triggered, and how long some operations take.
Timing the Event Loop # JavaScript concurrency model is based on a single-threaded event loop which means it can only run one task at a time. If, for example, some time-consuming task blocks the event loop, the user can perceive a freeze on a page as a result of the UI thread being starved.</description></item><item><title>Fetch Metadata</title><link>https://xsleaks.com/docs/defenses/opt-in/fetch-metadata/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/opt-in/fetch-metadata/</guid><description>Fetch Metadata Headers are sent by browsers in every request or navigation made by a page. These Headers provide context on how every request/navigation was initiated so that applications are able to make more informed decisions on how to respond to them. This allows servers to behave differently when they detect potential attacks (i.e. unexpected cross-origin requests)1. This mechanism can be very effective against cross-origin attacks like XSSI, XS-Leaks, Clickjacking, and CSRF.</description></item><item><title>Frame Counting</title><link>https://xsleaks.com/docs/attacks/frame-counting/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/frame-counting/</guid><description>Explanation # window references allow cross-origin pages to get access to some attributes of other pages. These references become available when using or allowing iframe and window.open. They provide some information (although limited) about the window as they still respect the Same Origin Policy.
One of the accessible attributes is window.length which provides the number of frames in the window. This attribute can give valuable information about a page to an attacker.</description></item><item><title>Framing Protections</title><link>https://xsleaks.com/docs/defenses/opt-in/xfo/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/opt-in/xfo/</guid><description>Explanation # A considerable number of XS-Leaks relies on some properties of iframes. If an attacker is unable to embed the contents of a page as an iframe then the attack may no longer be possible. To mitigate XS-Leaks which rely on this object, pages can forbid or select which origins can embed them. This is possible by using the X-Frame-Options Header or the CSP frame-ancestors directive.
Since a website enforcing Framing Protections can&amp;rsquo;t be embedded from an attacker origin, the website is not rendered and the JavaScript does not run.</description></item><item><title>Hybrid Timing</title><link>https://xsleaks.com/docs/attacks/timing-attacks/hybrid-timing/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/hybrid-timing/</guid><description>Hybrid Timing Attacks allow attackers to measure a combination of factors that influence the final timing measurement. These factors can be:
Network. Parsing. Retrieve and load subresources. Execution. Some of the factors differ in value depending on the application. This means that Network Timing might be more observable in pages with more backend processing while Execution Timing can be more observable in applications processing and displaying data within the browser.</description></item><item><title>ID Attribute</title><link>https://xsleaks.com/docs/attacks/id-attribute/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/id-attribute/</guid><description>Explanation # The id attribute is widely used to identify some HTML elements. Unfortunately, these ids can be leaked by leveraging the focus event and the URL fragment. There are two alternatives to complete this attack:
By using an iframe an attacker can load the target website once and brute-force the URL hash until the focus event fires. The onblur event can be used to detect when the target has focus 1.</description></item><item><title>Navigations</title><link>https://xsleaks.com/docs/attacks/navigations/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/navigations/</guid><description>Detecting if a cross-site page triggered a navigation (or didn&amp;rsquo;t) can be useful to an attacker. For example, a website may trigger a navigation in a certain endpoint depending on the status of the user.
To detect if any kind of navigation occurred, an attacker can:
Use an iframe and count the number of times the onload event is triggered. Check the value of History.length, accessible through any window reference.</description></item><item><title>Network Timing</title><link>https://xsleaks.com/docs/attacks/timing-attacks/network-timing/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/timing-attacks/network-timing/</guid><description>Network Timing side-channels have been present on the web since its beginning 1 2. These attacks achieved different levels of impact over time, gaining new attention when browsers started shipping high precision timers like performance.now().
To obtain timing measurements attackers must use a clock, either an implicit or explicit one. These clocks are usually interchangeable and only vary in accuracy and availability. For simplicity, this article will only address the performance.</description></item><item><title>Partitioned HTTP Cache</title><link>https://xsleaks.com/docs/defenses/browser-intrinsic/partitioned-cache/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/browser-intrinsic/partitioned-cache/</guid><description>Explanation # Cache probing attacks have been present on the web for a long time mainly because browsers HTTP cache is shared across all the websites visited by a user, allowing attackers to interact with it and infer private information from other origins.
Considering Opt-in solutions, applications can use the Vary Header combined with Fetch-Metadata to prevent cross-origin fetches to be affected by the site cache or use some workarounds to protect resources, which come with downsides.</description></item><item><title>postMessage Broadcasts</title><link>https://xsleaks.com/docs/attacks/postmessage-broadcasts/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/postmessage-broadcasts/</guid><description>Applications often use postMessage broadcasts to provide information to any interested origin. Apart from the obvious security issues (providing sensitive information to any origin) other problems might occur if a legitimate postMessage broadcast is not properly deployed 1.
If a broadcast happens based on user information, attackers might be able to leak that information if they can distinguish requests. There are multiple ways applications can be inconsistent with broadcasts based on user information:</description></item><item><title>Same-Site Cookies</title><link>https://xsleaks.com/docs/defenses/opt-in/same-site-cookies/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/opt-in/same-site-cookies/</guid><description>Explanation # Same-Site Cookies are one of the most impactful Security Mechanisms towards fixing security issues that involve cross-site requests. This mechanism allows applications to add a special restriction to cookies, forcing browsers to only append them in requests that are issued same-site 1. This type of cookies has two modes: Lax and Strict.
Lax V.s Strict # The only difference between Lax and Strict is that Lax mode allows cookies to be added to requests triggered by top-level navigations.</description></item><item><title>Scroll to Text Fragment</title><link>https://xsleaks.com/docs/attacks/experiments/scroll-to-text-fragment/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/experiments/scroll-to-text-fragment/</guid><description>Scroll to Text Fragment (STTF) is a new web platform feature that allows users to create a link to any part of a web page text. The fragment #:~:text= carries a text snippet that is highlighted and brought into the viewport by the browser. This feature can introduce a new XS-Leak if attackers are able to detect when this behavior occurs. This issue is very similar to the Scroll to CSS Selector XS-Leak.</description></item><item><title>Subresource Protections</title><link>https://xsleaks.com/docs/defenses/design-protections/subresource-protections/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/design-protections/subresource-protections/</guid><description>Random tokens # One of the principles of protecting subresources is the same as protecting endpoints from CSRF attacks. The difference from CSRF protections is that in the case of XS-Leaks, GET requests are the ones usually worth protecting. To apply this protection applications can append a (cryptographically strong) pseudorandom value, unique to each request/session, to make the URL of a subresource unpredictable to an attacker. The protection can be applied to the following types of subresources:</description></item><item><title>typeMustMatch</title><link>https://xsleaks.com/docs/attacks/historical/content-type/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/historical/content-type/</guid><description>typeMustMatch is a boolean that reflects the typeMustMatch attribute of the object element. It ensures a certain MIME type must be enforced when loading an object verifying if the Content-Type of the resource is the same as the one provided in the object. Unfortunately, this enforcement would allow attackers to leak the Content-Type and Status Codes returned by a website 1
Root Cause # Considering the snippet below, not_loaded would be rendered if the returned Content-Type of https://target/api did not match the one in type, or the server returned a status different than 200.</description></item><item><title>WebKit - ITP</title><link>https://xsleaks.com/docs/attacks/historical/itp/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/historical/itp/</guid><description>Intelligent Tracking Prevention (ITP) is a privacy feature part of WebKit Tracking Prevention technologies. It’s a conjunction of several features to prevent a website from tracking a user under a third-party context. Unfortunately, the initial design introduced a new XS-Leak 1, allowing attackers to abuse the states implicitly created by ITP to classify websites as trackers.
Root Cause # To classify whether a website had tracking capabilities, ITP collects statistics on resource loads as well as user interactions in websites such as clicks, taps, or text entries.</description></item><item><title>XS-Search</title><link>https://xsleaks.com/docs/attacks/xs-search/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/xs-search/</guid><description>Cross-Site Search (XS-Search) is an important attack and principle in the family of XS-Leaks. The attack abuses Query-Based Search Systems to leak user information from an attacker origin. The original attack used timing measurements to detect when a search system returned results or no results and works as follows:
Establish a baseline time for a request returning results (hit), and a baseline for a request with no results (miss). Start a timing attack on the request to the search endpoint, brute-forcing the first character (?</description></item><item><title>Cache Probing</title><link>https://xsleaks.com/docs/attacks/cache-probing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/attacks/cache-probing/</guid><description>The principle of Cache Probing consists of detecting whether some resource was cached by the browser. The concept is known since the begging of the web 1 and initially used timing differences to succeed.
When a user visits a website some resources such as images, scripts and HTML content are fetched and later cached by the browser (under certain conditions). This optimization will make future navigations faster as the browser will serve those resources from disk instead of requesting them again.</description></item></channel></rss>
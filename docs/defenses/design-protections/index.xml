<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Application Design on XS-Leaks Wiki</title><link>https://xsleaks.com/docs/defenses/design-protections/</link><description>Recent content in Application Design on XS-Leaks Wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://xsleaks.com/docs/defenses/design-protections/index.xml" rel="self" type="application/rss+xml"/><item><title>Cache Protections</title><link>https://xsleaks.com/docs/defenses/design-protections/cache-protections/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/design-protections/cache-protections/</guid><description>There are a number of different approaches for defending against cache probing based XS-Leaks.
Cache Protection via Cache-Control Headers # If it is acceptable to disable caching, this provides a strong defense against cache probing attacks. This means that every time someone loads a resource, the resource will have to be fetched again. This can be done by setting a Cache-Control: no-store header on every single response that you wish to protect.</description></item><item><title>Subresource Protections</title><link>https://xsleaks.com/docs/defenses/design-protections/subresource-protections/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.com/docs/defenses/design-protections/subresource-protections/</guid><description>The fundamental idea behind designing protections for subresources is that subresources cannot be targeted by XS-Leaks if the attacker cannot cause them to return any user data. If implemented correctly, this can be a very strong defense though it is likely to be tough to implement and could negatively impact the user experience.
It can be very effective to deploy this on any specific resources that are known to be especially sensitive to XS-Leaks.</description></item></channel></rss>